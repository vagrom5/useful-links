void get_subpulses(struct SubPulses* sub, struct AlgFskDet* afd, const PulseData* pulse) {
    afd_setrecinfo(afd);
    if (pulse->size <= afd->mindurticks) return;

    const int N = pulse->size;
    double* freqarr = pulse->frequency;
    double* amplarr = pulse->I_samples;
    const double sampling_freq = afd->recinfo->sampling_freq;

    // Инициализация структур данных
    struct Fifo *outfreq_fifo = fifoinit(afd->derivsmsz * 2, sizeof(double));
    struct Fifo *derivsm_fifo = fifoinit(afd->derivsmsz, sizeof(double));
    struct AdvFifo outfreq_adv;
    advinit(&outfreq_adv, afd->outfreqsmsz);
    
    double* outfreq_arr = malloc((N + afd->derivsmsz) * sizeof(double));
    memset(afd->hist, 0, afd->histsz * sizeof(double));

    // Первичное заполнение FIFO
    double freq0 = freqarr[0];
    int idx = 1;
    for (; idx < afd->derivsmsz * 2 && idx < N; idx++) {
        fifopush(outfreq_fifo);  // Место для нового элемента
        *(double*)fifotail(outfreq_fifo) = freqarr[idx];
        
        double deriv = freqarr[idx] - freq0;
        freq0 = freqarr[idx];
        
        if (fifosize(derivsm_fifo) >= afd->derivsmsz) {
            fifopop(derivsm_fifo);
        }
        fifopush(derivsm_fifo);
        *(double*)fifotail(derivsm_fifo) = deriv;
    }

    // Основная обработка сигнала
    int curjumpext = 0;
    double jumpfreq = 0.0;
    for (; idx < N; idx++) {
        fifopush(outfreq_fifo);
        *(double*)fifotail(outfreq_fifo) = freqarr[idx];
        
        double deriv = freqarr[idx] - freq0;
        freq0 = freqarr[idx];
        
        double deriv_front = fifohead(derivsm_fifo) ? *(double*)fifohead(derivsm_fifo) : 0.0;
        fifopop(derivsm_fifo);
        
        fifopush(derivsm_fifo);
        *(double*)fifotail(derivsm_fifo) = deriv;
        
        if (deriv * deriv_front <= afd->phjumpthr) {
            curjumpext = afd->phjumpsz;
            if (jumpfreq == 0.0 && fifohead(outfreq_fifo)) {
                jumpfreq = *(double*)fifohead(outfreq_fifo);
            }
        }
        
        double outval = (curjumpext-- > 0) ? jumpfreq : 
                      (fifohead(outfreq_fifo) ? *(double*)fifohead(outfreq_fifo) : 0.0);
        advfifopush(&outfreq_adv, outval);
        outfreq_arr[idx] = outfreq_adv.currmean;
        
        int histidx = round((outfreq_adv.currmean - afd->minfreq) * 10.0);
        if (histidx >= 0 && histidx < afd->histsz) afd->hist[histidx]++;
    }

    // Обработка остаточных данных
    for (int i = 0; i < afd->derivsmsz; i++) {
        double outval = (curjumpext-- > 0) ? jumpfreq : 
                      (fifohead(outfreq_fifo) ? *(double*)fifohead(outfreq_fifo) : 0.0);
        fifopop(outfreq_fifo);
        
        advfifopush(&outfreq_adv, outval);
        outfreq_arr[N + i] = outfreq_adv.currmean;
        
        int histidx = round((outfreq_adv.currmean - afd->minfreq) * 10.0);
        if (histidx >= 0 && histidx < afd->histsz) afd->hist[histidx]++;
    }

    // Нормализация гистограммы
    double histmax = 0.0;
    for (int i = 0; i < afd->histsz; i++) {
        if (afd->hist[i] > histmax) histmax = afd->hist[i];
    }
    for (int i = 0; i < afd->histsz; i++) {
        afd->hist[i] /= histmax;
        if (afd->hist[i] < afd->histthr) afd->hist[i] = 0.0;
    }

    // Определение частотных диапазонов
    double freqerr = afd->histminkeying / 4.0;
    int limits_count = 0;
    double weigfreqsum = 0.0, weigsum = 0.0;
    int lastfreqidx = -afd->histminkeying;
    
    for (int i = 0; i < afd->histsz; i++) {
        if (afd->hist[i] > 0.0) {
            weigfreqsum += i * afd->hist[i];
            weigsum += afd->hist[i];
            lastfreqidx = i;
        } else if (i - lastfreqidx >= afd->histminkeying && weigsum > 0.0) {
            double freq = afd->minfreq + weigfreqsum / (weigsum * 10.0);
            afd->freqrates[limits_count] = freq;
            afd->freq_limits[limits_count][0] = freq - freqerr;
            afd->freq_limits[limits_count][1] = freq + freqerr;
            limits_count++;
            weigfreqsum = weigsum = 0.0;
        }
    }
    if (weigsum > 0.0) {
        double freq = afd->minfreq + weigfreqsum / (weigsum * 10.0);
        afd->freqrates[limits_count] = freq;
        afd->freq_limits[limits_count][0] = freq - freqerr;
        afd->freq_limits[limits_count][1] = freq + freqerr;
        limits_count++;
    }

    // Обнаружение субимпульсов
    int durticks = 0;
    double amplsum = 0.0;
    int current_limit = -1;
    
    for (int i = 0; i < N; i++) {
        int found = -1;
        for (int j = 0; j < limits_count; j++) {
            if (outfreq_arr[i] >= afd->freq_limits[j][0] && 
                outfreq_arr[i] <= afd->freq_limits[j][1]) {
                found = j;
                break;
            }
        }
        
        if (current_limit >= 0) {
            if (found == current_limit) {
                amplsum += amplarr[i];
                durticks++;
                continue;
            }
            
            int is_outlier = 0;
            int end = (i + afd->pausesz < N) ? i + afd->pausesz : N;
            for (int j = i + 1; j < end; j++) {
                if (outfreq_arr[j] >= afd->freq_limits[current_limit][0] && 
                    outfreq_arr[j] <= afd->freq_limits[current_limit][1]) {
                    is_outlier = 1;
                    break;
                }
            }
            
            if (is_outlier) {
                amplsum += amplarr[i];
                durticks++;
                continue;
            }
            
            if (durticks >= afd->mindurticks) {
                if (sub->count >= sub->capacity) {
                    sub->capacity = (sub->capacity == 0) ? 4 : sub->capacity * 2;
                    sub->freqs = realloc(sub->freqs, sub->capacity * sizeof(double));
                    sub->ampls = realloc(sub->ampls, sub->capacity * sizeof(double));
                    sub->durs = realloc(sub->durs, sub->capacity * sizeof(double));
                }
                sub->freqs[sub->count] = afd->freqrates[current_limit];
                sub->ampls[sub->count] = AmplConv(amplsum / durticks, amADC, ammV);
                sub->durs[sub->count] = Sample2Time(durticks, tmMicroSeconds, sampling_freq);
                sub->count++;
            }
            amplsum = durticks = 0;
        }
        
        if (found >= 0) {
            current_limit = found;
            amplsum = amplarr[i];
            durticks = 1;
        } else {
            current_limit = -1;
        }
    }
    
    // Финализация последнего субимпульса
    if (current_limit >= 0 && durticks >= afd->mindurticks) {
        if (sub->count >= sub->capacity) {
            sub->capacity = (sub->capacity == 0) ? 4 : sub->capacity * 2;
            sub->freqs = realloc(sub->freqs, sub->capacity * sizeof(double));
            sub->ampls = realloc(sub->ampls, sub->capacity * sizeof(double));
            sub->durs = realloc(sub->durs, sub->capacity * sizeof(double));
        }
        sub->freqs[sub->count] = afd->freqrates[current_limit];
        sub->ampls[sub->count] = AmplConv(amplsum / durticks, amADC, ammV);
        sub->durs[sub->count] = Sample2Time(durticks, tmMicroSeconds, sampling_freq);
        sub->count++;
    }

    // Освобождение ресурсов
    free(outfreq_arr);
    fifofree(outfreq_fifo);
    fifofree(derivsm_fifo);
}
afd->freq_limits = (double**)malloc(2*N*sizeof(double));
    afd->freq_limits[0] = (double*)malloc(N*sizeof(double));
    afd->freq_limits[1] = (double*)malloc(N*sizeof(double));
struct AlgFskDet {
    
    double **freq_limits;
}



Program received signal SIGSEGV, Segmentation fault.
0x000000000041ea60 in get_subpulses (sub=0x279f8e0, afd=0x27a0660) at src/core.c:675
675                 afd->freq_limits[limits_count][0] = freq - freqerr;
(gdb) bt
#0  0x000000000041ea60 in get_subpulses (sub=0x279f8e0, afd=0x27a0660) at src/core.c:675
#1  0x0000000000416025 in open_pulse_db (ctx=0x6b70f8 <xlib+56>, 
    data=0x2dc5ea8 "\201\177\005\200t", ldata=231424) at src/db.c:1615
#2  0x00000000004125de in loadpulse (ctx=0x6b70f8 <xlib+56>, 
    shwpls=0x6bc7c8 <dbtbl+4648>, dbconn=0x26ba390 <dbconn>) at src/db.c:943
#3  0x0000000000412679 in loadbutton (ctx=0x6b70f8 <xlib+56>, dbconn=0x26ba390 <dbconn>, 
    dbt=0x6bb5a0 <dbtbl>) at src/db.c:951
#4  0x000000000041305e in dbgui (ctx=0x6b70f8 <xlib+56>, dbconn=0x26ba390 <dbconn>, 
    flgdb=0x6bb16e <flgdb>) at src/db.c:1070
#5  0x0000000000487503 in gui (ctx=0x6b70f8 <xlib+56>) at src/main.c:497
#6  0x0000000000487647 in mainloop (ctx=0x6b70f8 <xlib+56>) at src/main.c:534
#7  0x0000000000487b6c in main (argc=2, argv=0x7fffffffe1f8) at src/main.c:653
(gdb) f 0
#0  0x000000000041ea60 in get_subpulses (sub=0x279f8e0, afd=0x27a0660) at src/core.c:675
675                 afd->freq_limits[limits_count][0] = freq - freqerr;
(gdb) f freq
#0  0x0000000000000000 in ?? ()
(gdb) [ freq
Undefined command: "".  Try "help".
(gdb) p freq
No symbol "freq" in current context.
(gdb) f 0
#0  0x000000000041ea60 in get_subpulses (sub=0x279f8e0, afd=0x27a0660) at src/core.c:675
675                 afd->freq_limits[limits_count][0] = freq - freqerr;
(gdb) p freq
$1 = 1406.0999999999999
(gdb) p freqerr
$2 = 2.5
(gdb) p limits_count
$3 = 0
(gdb) p afd->freq_limits[limits_count][0]
Cannot access memory at address 0x0

afd->freq_limits = (double**)malloc(2*N*sizeof(double*));
    afd->freq_limits[0] = (double*)malloc(N*sizeof(double));
    afd->freq_limits[1] = (double*)malloc(N*sizeof(double));


