void get_subpulses(struct SubPulses* sub, struct AlgFskDet* afd, const PulseData* pulse) {
    // Инициализация и проверки
    if (!pulse || pulse->size <= afd->mindurticks) return;
    
    const int N = pulse->size;
    double* freqarr = pulse->frequency;
    double* amplarr = pulse->I_samples;
    const double sampling_freq = afd->recinfo->sampling_freq;

    // Выделение памяти для временных данных
    double* outfreq_arr = (double*)malloc((N + afd->derivsmsz) * sizeof(double));
    memset(afd->hist, 0, afd->histsz * sizeof(double));

    // Инициализация FIFO структур
    struct Fifo outfreq_fifo, derivsm_fifo;
    fifoinit(&outfreq_fifo, afd->derivsmsz * 2, sizeof(double));
    fifoinit(&derivsm_fifo, afd->derivsmsz, sizeof(double));
    struct AdvFifo outfreq_adv;
    advinit(&outfreq_adv, afd->outfreqsmsz);

    // Первичное заполнение FIFO
    double freq0 = freqarr[0];
    int idx = 1;
    for (; idx < afd->derivsmsz * 2 && idx < N; idx++) {
        fifopush(&outfreq_fifo, &freqarr[idx]);
        
        double deriv = freqarr[idx] - freq0;
        freq0 = freqarr[idx];
        
        if (fifosize(&derivsm_fifo) >= afd->derivsmsz) {
            fifopop(&derivsm_fifo);
        }
        fifopush(&derivsm_fifo, &deriv);
    }

    // Основная обработка сигнала
    int curjumpext = 0;
    double jumpfreq = 0.0;
    for (; idx < N; idx++) {
        fifopush(&outfreq_fifo, &freqarr[idx]);
        
        double deriv = freqarr[idx] - freq0;
        freq0 = freqarr[idx];
        
        double deriv_front = fifofront(&derivsm_fifo);
        fifopop(&derivsm_fifo);
        fifopush(&derivsm_fifo, &deriv);
        
        if (deriv * deriv_front <= afd->phjumpthr) {
            curjumpext = afd->phjumpsz;
            if (jumpfreq == 0.0) {
                jumpfreq = fifofront(&outfreq_fifo);
            }
        }
        
        double outval = (curjumpext-- > 0) ? jumpfreq : fifofront(&outfreq_fifo);
        advfifopush(&outfreq_adv, outval);
        outfreq_arr[idx] = outfreq_adv.currmean;
        
        int histidx = (int)round((outfreq_adv.currmean - afd->minfreq) * 10.0);
        if (histidx >= 0 && histidx < afd->histsz) afd->hist[histidx] += 1.0;
    }

    // Обработка остаточных данных
    for (int i = 0; i < afd->derivsmsz; i++) {
        double outval = (curjumpext-- > 0) ? jumpfreq : fifofront(&outfreq_fifo);
        fifopop(&outfreq_fifo);
        
        advfifopush(&outfreq_adv, outval);
        outfreq_arr[N + i] = outfreq_adv.currmean;
        
        int histidx = (int)round((outfreq_adv.currmean - afd->minfreq) * 10.0);
        if (histidx >= 0 && histidx < afd->histsz) afd->hist[histidx] += 1.0;
    }

    // Нормализация гистограммы
    double histmax = 0.0;
    for (int i = 0; i < afd->histsz; i++) {
        if (afd->hist[i] > histmax) histmax = afd->hist[i];
    }
    for (int i = 0; i < afd->histsz; i++) {
        afd->hist[i] /= histmax;
        if (afd->hist[i] < afd->histthr) afd->hist[i] = 0.0;
    }

    // Определение частотных диапазонов
    double freqerr = afd->histminkeying / 4.0;
    int limits_count = 0;
    double weigfreqsum = 0.0, weigsum = 0.0;
    int lastfreqidx = -afd->histminkeying;
    
    // Выделяем память для частотных диапазонов
    afd->freq_limits = (double**)malloc(2 * sizeof(double*));
    afd->freq_limits[0] = (double*)malloc(afd->max_limits * sizeof(double));
    afd->freq_limits[1] = (double*)malloc(afd->max_limits * sizeof(double));
    
    for (int i = 0; i < afd->histsz; i++) {
        if (afd->hist[i] > 0.0) {
            weigfreqsum += i * afd->hist[i];
            weigsum += afd->hist[i];
            lastfreqidx = i;
        } else if (i - lastfreqidx >= afd->histminkeying && weigsum > 0.0) {
            double freq = afd->minfreq + weigfreqsum / (weigsum * 10.0);
            afd->freq_limits[0][limits_count] = freq - freqerr;
            afd->freq_limits[1][limits_count] = freq + freqerr;
            limits_count++;
            weigfreqsum = weigsum = 0.0;
        }
    }
    if (weigsum > 0.0) {
        double freq = afd->minfreq + weigfreqsum / (weigsum * 10.0);
        afd->freq_limits[0][limits_count] = freq - freqerr;
        afd->freq_limits[1][limits_count] = freq + freqerr;
        limits_count++;
    }

    // Обнаружение субимпульсов
    int durticks = 0;
    double amplsum = 0.0;
    int current_limit = -1;
    
    for (int i = 0; i < N; i++) {
        int found = -1;
        for (int j = 0; j < limits_count; j++) {
            if (outfreq_arr[i] >= afd->freq_limits[0][j] && 
                outfreq_arr[i] <= afd->freq_limits[1][j]) {
                found = j;
                break;
            }
        }
        
        if (current_limit >= 0) {
            if (found == current_limit) {
                amplsum += amplarr[i];
                durticks++;
                continue;
            }
            
            int is_outlier = 0;
            int end = (i + afd->pausesz < N) ? i + afd->pausesz : N;
            for (int j = i + 1; j < end; j++) {
                if (outfreq_arr[j] >= afd->freq_limits[0][current_limit] && 
                    outfreq_arr[j] <= afd->freq_limits[1][current_limit]) {
                    is_outlier = 1;
                    break;
                }
            }
            
            if (is_outlier) {
                amplsum += amplarr[i];
                durticks++;
                continue;
            }
            
            if (durticks >= afd->mindurticks) {
                sub_add(sub, afd->freqrates[current_limit], 
                       AmplConv(amplsum/durticks, amADC, ammV), 
                       Sample2Time(durticks, tmMicroSeconds, sampling_freq));
            }
            amplsum = durticks = 0;
        }
        
        if (found >= 0) {
            current_limit = found;
            amplsum = amplarr[i];
            durticks = 1;
        } else {
            current_limit = -1;
        }
    }
    
    // Финализация последнего субимпульса
    if (current_limit >= 0 && durticks >= afd->mindurticks) {
        sub_add(sub, afd->freqrates[current_limit], 
               AmplConv(amplsum/durticks, amADC, ammV), 
               Sample2Time(durticks, tmMicroSeconds, sampling_freq));
    }

    // Освобождение памяти
    free(outfreq_arr);
    fifofree(&outfreq_fifo);
    fifofree(&derivsm_fifo);
    if (afd->freq_limits) {
        free(afd->freq_limits[0]);
        free(afd->freq_limits[1]);
        free(afd->freq_limits);
    }
}