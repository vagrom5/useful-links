void get_subpulses(struct SubPulses* sub, struct AlgFskDet* afd, const PulseData* pulse) {
    // Инициализация и проверки
    afd_setrecinfo(afd);
    if (!pulse || pulse->size <= afd->mindurticks) return;
    
    const int N = pulse->size;
    double* freqarr = pulse->frequency;
    double* amplarr = pulse->I_samples;
    const double sampling_freq = afd->recinfo->sampling_freq;
    const int start_idx = afd->derivsmsz * 2;

    // Выделение памяти для временных данных
    double* outfreq_arr = malloc((N + afd->derivsmsz) * sizeof(double));
    if (!outfreq_arr) {
        fprintf(stderr, "Memory allocation failed for outfreq_arr\n");
        return;
    }

    // Инициализация FIFO структур
    struct Fifo *outfreq_fifo = fifoinit(afd->derivsmsz * 2, sizeof(double));
    struct Fifo *derivsm_fifo = fifoinit(afd->derivsmsz, sizeof(double));
    struct AdvFifo outfreq_adv;
    advinit(&outfreq_adv, afd->outfreqsmsz);

    if (!outfreq_fifo || !derivsm_fifo) {
        fprintf(stderr, "FIFO initialization failed\n");
        free(outfreq_arr);
        if (outfreq_fifo) fifofree(outfreq_fifo);
        if (derivsm_fifo) fifofree(derivsm_fifo);
        return;
    }

    // Первичное заполнение FIFO
    double freq0 = freqarr[0];
    int idx = 1;
    for (; idx < start_idx && idx < N; idx++) {
        if (!fifopush(outfreq_fifo)) break;
        *(double*)fifotail(outfreq_fifo) = freqarr[idx];
        
        double deriv = freqarr[idx] - freq0;
        freq0 = freqarr[idx];
        
        if (fifosize(derivsm_fifo) >= afd->derivsmsz) {
            fifopop(derivsm_fifo);
        }
        if (!fifopush(derivsm_fifo)) break;
        *(double*)fifotail(derivsm_fifo) = deriv;
    }

    // Основная обработка сигнала
    int curjumpext = 0;
    double jumpfreq = 0.0;
    for (; idx < N; idx++) {
        if (!fifopush(outfreq_fifo)) break;
        *(double*)fifotail(outfreq_fifo) = freqarr[idx];
        
        double deriv = freqarr[idx] - freq0;
        freq0 = freqarr[idx];
        
        double deriv_front = fifohead(derivsm_fifo) ? *(double*)fifohead(derivsm_fifo) : 0.0;
        fifopop(derivsm_fifo);
        
        if (!fifopush(derivsm_fifo)) break;
        *(double*)fifotail(derivsm_fifo) = deriv;
        
        if (deriv * deriv_front <= afd->phjumpthr) {
            curjumpext = afd->phjumpsz;
            if (jumpfreq == 0.0 && fifohead(outfreq_fifo)) {
                jumpfreq = *(double*)fifohead(outfreq_fifo);
            }
        }
        
        double outval = (curjumpext-- > 0) ? jumpfreq : 
                      (fifohead(outfreq_fifo) ? *(double*)fifohead(outfreq_fifo) : 0.0);
        advfifopush(&outfreq_adv, outval);
        outfreq_arr[idx] = outfreq_adv.currmean;
        
        int histidx = (int)round((outfreq_adv.currmean - afd->minfreq) * 10.0);
        if (histidx >= 0 && histidx < afd->histsz) afd->hist[histidx] += 1.0;
    }

    // Обработка остаточных данных
    for (int i = 0; i < afd->derivsmsz; i++) {
        if (fifoempty(outfreq_fifo)) break;
        
        double outval = (curjumpext-- > 0) ? jumpfreq : 
                      (fifohead(outfreq_fifo) ? *(double*)fifohead(outfreq_fifo) : 0.0);
        fifopop(outfreq_fifo);
        
        advfifopush(&outfreq_adv, outval);
        outfreq_arr[N + i] = outfreq_adv.currmean;
        
        int histidx = (int)round((outfreq_adv.currmean - afd->minfreq) * 10.0);
        if (histidx >= 0 && histidx < afd->histsz) afd->hist[histidx] += 1.0;
    }

    // Нормализация гистограммы
    double histmax = 0.0;
    for (int i = 0; i < afd->histsz; i++) {
        if (afd->hist[i] > histmax) histmax = afd->hist[i];
    }
    if (histmax > 0.0) {
        for (int i = 0; i < afd->histsz; i++) {
            afd->hist[i] /= histmax;
            if (afd->hist[i] < afd->histthr) afd->hist[i] = 0.0;
        }
    }

    // Определение частотных диапазонов
    double freqerr = afd->histminkeying / 4.0;
    int limits_count = 0;
    double weigfreqsum = 0.0, weigsum = 0.0;
    int lastfreqidx = -afd->histminkeying;
    
    // Выделяем память для частотных диапазонов (без realloc)
    // Используем временные массивы
    double* freqrates_tmp = malloc(N * sizeof(double));
    double* lower_limits = malloc(N * sizeof(double));
    double* upper_limits = malloc(N * sizeof(double));
    
    if (!freqrates_tmp || !lower_limits || !upper_limits) {
        fprintf(stderr, "Memory allocation failed for frequency limits\n");
        free(freqrates_tmp);
        free(lower_limits);
        free(upper_limits);
        goto cleanup;
    }
    
    for (int i = 0; i < afd->histsz; i++) {
        if (afd->hist[i] > 0.0) {
            weigfreqsum += i * afd->hist[i];
            weigsum += afd->hist[i];
            lastfreqidx = i;
        } else if (i - lastfreqidx >= afd->histminkeying && weigsum > 0.0) {
            double freq = afd->minfreq + weigfreqsum / (weigsum * 10.0);
            freqrates_tmp[limits_count] = freq;
            lower_limits[limits_count] = freq - freqerr;
            upper_limits[limits_count] = freq + freqerr;
            limits_count++;
            weigfreqsum = weigsum = 0.0;
        }
    }
    if (weigsum > 0.0) {
        double freq = afd->minfreq + weigfreqsum / (weigsum * 10.0);
        freqrates_tmp[limits_count] = freq;
        lower_limits[limits_count] = freq - freqerr;
        upper_limits[limits_count] = freq + freqerr;
        limits_count++;
    }

    // Обнаружение субимпульсов
    int durticks = 0;
    double amplsum = 0.0;
    int current_limit = -1;
    
    for (int i = start_idx; i < N; i++) {
        int found = -1;
        for (int j = 0; j < limits_count; j++) {
            if (outfreq_arr[i] >= lower_limits[j] && 
                outfreq_arr[i] <= upper_limits[j]) {
                found = j;
                break;
            }
        }
        
        if (current_limit >= 0) {
            if (found == current_limit) {
                amplsum += amplarr[i];
                durticks++;
                continue;
            }
            
            // Проверка на выброс
            int is_outlier = 0;
            int end = (i + afd->pausesz < N) ? i + afd->pausesz : N;
            for (int j = i + 1; j < end; j++) {
                if (outfreq_arr[j] >= lower_limits[current_limit] && 
                    outfreq_arr[j] <= upper_limits[current_limit]) {
                    is_outlier = 1;
                    break;
                }
            }
            
            if (is_outlier) {
                amplsum += amplarr[i];
                durticks++;
                continue;
            }
            
            // Завершение субимпульса
            if (durticks >= afd->mindurticks) {
                // Увеличиваем емкость при необходимости
                if (sub->count >= sub->capacity) {
                    int new_capacity = sub->capacity ? sub->capacity * 2 : 4;
                    double* new_freqs = realloc(sub->freqs, new_capacity * sizeof(double));
                    double* new_ampls = realloc(sub->ampls, new_capacity * sizeof(double));
                    double* new_durs = realloc(sub->durs, new_capacity * sizeof(double));
                    
                    if (!new_freqs || !new_ampls || !new_durs) {
                        fprintf(stderr, "Memory reallocation failed for subpulses\n");
                        free(new_freqs);
                        free(new_ampls);
                        free(new_durs);
                        break;
                    }
                    
                    sub->freqs = new_freqs;
                    sub->ampls = new_ampls;
                    sub->durs = new_durs;
                    sub->capacity = new_capacity;
                }
                
                sub->freqs[sub->count] = freqrates_tmp[current_limit];
                sub->ampls[sub->count] = AmplConv(amplsum / durticks, amADC, ammV);
                sub->durs[sub->count] = Sample2Time(durticks, tmMicroSeconds, sampling_freq);
                sub->count++;
            }
            amplsum = durticks = 0;
            current_limit = -1;
        }
        
        // Начало нового субимпульса
        if (found >= 0) {
            current_limit = found;
            amplsum = amplarr[i];
            durticks = 1;
        }
    }
    
    // Финализация последнего субимпульса
    if (current_limit >= 0 && durticks >= afd->mindurticks) {
        if (sub->count >= sub->capacity) {
            int new_capacity = sub->capacity ? sub->capacity * 2 : 4;
            double* new_freqs = realloc(sub->freqs, new_capacity * sizeof(double));
            double* new_ampls = realloc(sub->ampls, new_capacity * sizeof(double));
            double* new_durs = realloc(sub->durs, new_capacity * sizeof(double));
            
            if (new_freqs && new_ampls && new_durs) {
                sub->freqs = new_freqs;
                sub->ampls = new_ampls;
                sub->durs = new_durs;
                sub->capacity = new_capacity;
            }
        }
        
        if (sub->count < sub->capacity) {
            sub->freqs[sub->count] = freqrates_tmp[current_limit];
            sub->ampls[sub->count] = AmplConv(amplsum / durticks, amADC, ammV);
            sub->durs[sub->count] = Sample2Time(durticks, tmMicroSeconds, sampling_freq);
            sub->count++;
        }
    }

cleanup:
    // Освобождение ресурсов
    free(outfreq_arr);
    fifofree(outfreq_fifo);
    fifofree(derivsm_fifo);
    free(freqrates_tmp);
    free(lower_limits);
    free(upper_limits);
}